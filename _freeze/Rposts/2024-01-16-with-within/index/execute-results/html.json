{
  "hash": "d1a550e3a1be902a310f068a647df4d5",
  "result": {
    "markdown": "---\ntitle: \"`reduce` in `purrr`\"\ndescription: \"The beauty of functional programming\"\nauthor:\n  - name: Joan Tan\n    url: https://joantan.org/\n    orcid: 0000-0001-6374-1568\n    affiliation: Department of Econometrics and Business Statistics, Monash University/ NAB \n    affiliation-url: https://www.monash.edu/business/econometrics-and-business-statistics/\ndate: 01-15-2024\ncategories: [R, advanced, functional] # self-defined categories\ncitation: \n  url: https://joantan.org/R/2024-01-15-purrr-reduce/ \nimage: reduce_purrr.jpeg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\nOne of the function that seems quite confusing at first but it works wonders when you unleashed its power is `reduce` from the `purrr` package.\n\n`reduce()` function is used to reduce a list to a single value by iteratively applying a binary function to each combination of the element of a vector. The examples below show three different level of examples to help understand how `reduce()` function works in each case here.\n\nThe general syntax of `reduce()` function is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreduce(.x, .f, ..., .init = NULL)\n```\n:::\n\n\n- `.x` is a vector\n- `.f` is a function of two arguments\n- `...` is additional arguments to be passed to `.f`\n- `.init` is an optional initial value for `.x`\n\n## Example 1: Summing up a vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nx <- c(1, 2, 3, 4, 5)\nreduce(x, `+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\n**Explanation:**\n\n- `x` is a vector of numbers from 1 to 5\n- `reduce()` function takes in two arguments: `x` and `+`\n- `+` is a function of two arguments, which is the sum of two numbers\n- `reduce()` function will apply `+` function to each combination of the element of `x` vector\n- `reduce()` function will return a single value, which is the sum of all the elements in `x` vector\n- `reduce()` function is equivalent to `sum(x)` \n- `reduce()` function is equivalent to `sum(x, 0)` if `.init` is specified\n- in this case, the following iteration is performed.  \n  - sum(1, 2) = 3 (sum of first 2 elements)\n  - sum(3, 3) = 6 (sum of first 2 elements plus third element)\n  - sum(6, 4) = 10 (sum of first 3 elements plus fourth element)\n  - sum(10, 5) = 15 (sum of first 4 elements plus fifth element)\n  Therefore the `reduce()` function here simplify the procedure above and return only a single output of 15.\n  \n**Your turn** {{< fa pencil title=\"pencil\" >}}\n\nTry to put the initial value of 10 to start with and see what happens. Can you explain?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreduce(x, `+`, .init = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n:::\n\n  \n## Example 2: Summing up a list of vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n```\n:::\n\n```{.r .cell-code}\nreduce(x, `+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12 15 18\n```\n:::\n:::\n\n\n**Explanation:**\n\n- `x` is a list of vectors.   \n- `reduce()` function takes in two arguments: `x` and `+`.   \n- `+` is a function of two arguments, which is the sum of two numbers.   \n- `reduce()` function will apply `+` function to each combination of the element of `x` list.   \n- `reduce()` function is equivalent to `sum(unlist(x))`.   \n- `reduce()` function is equivalent to `sum(unlist(x), 0)` if `.init` is specified.   \n- in this case, the following iteration is performed.      \n   - sum(1, 4, 7) = 12 (sum of first elements from each list).   \n   - sum(2, 5, 8) = 15 (sum of first 2 elements).   \n   - sum(3, 6, 9) = 10 (sum of first 3 elements).   \n  Therefore the `reduce()` function here simplify the procedure above and return only a single.  output for each iterative summation procedure for first element, second element and third element respectively.  \n\n## Example 3: Calculate rolling sum for 3 lags value\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nx <- tibble(day = 1:10, \n               value = rnorm(n = 10))\n\nx %>% \n  mutate(testing = reduce(map(0:2, ~lag(value, .x)), `+`)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 Ã— 3\n     day   value testing\n   <int>   <dbl>   <dbl>\n 1     1 -0.560   NA    \n 2     2 -0.230   NA    \n 3     3  1.56     0.768\n 4     4  0.0705   1.40 \n 5     5  0.129    1.76 \n 6     6  1.72     1.91 \n 7     7  0.461    2.31 \n 8     8 -1.27     0.911\n 9     9 -0.687   -1.49 \n10    10 -0.446   -2.40 \n```\n:::\n:::\n\n\n**Explanation:**\n\n- `x` is a tibble with 2 columns: `day` and `value`.\n- `day` is a sequence of numbers from 1 to 10.\n- `value` is a sequence of random numbers generated from normal distribution.\n- `map()` function is used to apply `lag()` function to each element of the vector `0:2`.\n- `lag()` function is used to shift the value of `value` column by 0, 1 and 2 lags respectively.\n- `reduce()` function is used to apply `+` function to each combination of the element of `map()` function.\n- `reduce()` function is equivalent to `lag(value, 0) + lag(value, 1) + lag(value, 2)`.\n- in this case, the following iteration is performed.  \n  - day 1: lag(value, 0) + lag(value, 1) + lag(value, 2) = -0.560 + NA + NA = NA \n  - day 2: lag(value, 0) + lag(value, 1) + lag(value, 2) = -0.230 + NA + NA = NA\n  - day 3: lag(value, 0) + lag(value, 1) + lag(value, 2) = 1.558 + -0.230 + -0.560 = 0.768\n  - day 4: lag(value, 0) + lag(value, 1) + lag(value, 2) = 0.070 + 1.558 + -0.230 = 1.399\n  - day 5: lag(value, 0) + lag(value, 1) + lag(value, 2) = 0.129 + 0.070 + 1.558 = 1.757\n  and so on. This is equivalent to the `rollsum()` function from the `zoo` package. It basically calculate the rolling sum for the last 3 lags value.\n  \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}