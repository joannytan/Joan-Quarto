[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Who is Joan?",
    "section": "",
    "text": "I’m the educator/practitioner who is passionate about data science and teaching. I have been teaching data science courses for the past 12 years. I have taught over thousands of students. I have taught students from different backgrounds and different levels in different countries.\nMy background is in applied statistics – I was fortunate enough to obtain my undergraduate degree, master degree and my PhD degree all under various scholarships.\nI have been working in both the banking and education industry. Both are very fascinating and challenging. In reality, the practical side of statistics is very different from the theoretical side. I constantly need to learn new things and keep up with the latest technology. I am very fortunate to have the opportunity to work in both industries."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dr. Joan Tan",
    "section": "",
    "text": "Hello, I am Joan, a passionate data analyst who is dedicated to exploring the world of data and discovering insights that can drive positive change. I have always been fascinated by the power of data to tell stories and reveal patterns. I love nothing more than diving into complex data sets and using the skill in programming, statistics, and machine learning to extract meaningful insights. I hope to inspire others to embrace the power of data and use it to make a difference to your career.\nWhen I aren’t busy exploring the world of data science, I enjoy spending my free time pursuing other passions. I love Baking! I loves nothing more than experimenting with new recipes and sharing my creations with friends and family. I also enjoy reading productivity books, which I find inspiring and motivating. I believes that by learning from the experiences of others and adopting new strategies for managing time and staying focused, I can be more effective in all aspects of my life. Whether I am in the kitchen or curies up with a good book, I always seeking new ways to challenge myself and grow as a person."
  },
  {
    "objectID": "publication.html",
    "href": "publication.html",
    "title": "Publication",
    "section": "",
    "text": "Ha, J., Tan, P.P., & Goh, K.L. (2018). Linear and nonlinear causal relationship between energy consumption and economic growth in China: New evidence based on wavelet analysis. PLoS ONE 13 (5): e0197785. https://doi.org/10.1371/journal. pone.0197785\nChin, W.C., Lee, M.C., and Tan, P.P. (2016), Heterogeneous Market Hypothesis Evaluation using Multipower Variation Volatility, Communications in Statistics-Simulation and Computation, pp. 1-14, published online on 19 Aug 2016.\nChin, W.C., Lee, M.C., and Tan, P.P., Lee, C. Y., and Tan, N. L. (2016), Dynamic Long Memory High Frequency Multipower Variation Volatility Evaluations for S&P 500, Modern Applied Science, Vol 10, Issue 5.\nTan, P.P., Galagedera, D.U.A., and Ting, S.S. (2015), Modelling Price Movement in Trading Volume-Volatility Relation, Malaysian Journal of Economic Studies, 52(2), pp. 135-156.\nTan, P.P., and Galagedera, D.U.A. (2015), Dynamics of Idiosyncratic Volatility: an Emerging Market Perspective, Global Economic Review, Vol 44, Issue 1, pp. 74-100.\nTang, T.C., and Tan, P.P. (2015), Real Interest Rate and House Prices in Malaysia: An Empirical Study, Economics Bulletin, Vol 35, Issue 1, pp. 270-275.\nChin, W. C., I. Zaidi, Tan, P. P. and Lee, M. C. (2015), The Computation of High Frequency S&P 500 Long-range Dependence Volatility Using Dynamic Modified Rescaled Adjusted Range Approach, Applied Mathematical Sciences, Vol 9, pp. 5915- 5924.\nLiau, B.Y. and Tan, P.P. (2014), Gaining Customer Knowledge in Low Cost Airlines Through Text Mining. Industrial Management & Data System, Vol 114, Issue 9, pp. 1344-1359.\nTan, P.P., Chin, W.C. and Galagedera, D.U.A. (2014), A Wavelet-Based Evaluation of Time-Varying Long Memory of Equity Markets: A Paradigm in Crisis. Physica A: Statistical Mechanics and its Applications, Vol 410, pp. 345-358.\nTan, P.P., Galagedera, D.U.A. and Ting, S.S. (2014), Modelling Price Movement in Trading Volume-Volatility Relation, Malaysian Journal of Economic Studies, Volume 52, Issue 2, pp. 135-156.\nTan, P.P, Galagedera, D.U.A, Maharaj, E. A. (2012), A Wavelet Based Investigation of Long Memory in Stock Returns, Physica A: Statistical Mechanics and its Applications Netherlands, Vol 391, Issue 7, pp. 2330-2341.\nTan, P.P, Galagedera, D.U.A, Maharaj, E. A. (2011), Are Asia-Pacific Stock Markets Predictable? Evidence from Wavelet-based Fractional Integration Estimator, World Academy of Science, Engineering and Technology 59, pp. 1921-1926.\nTan, P. P. and Goh K.L. (2009), Structural Breaks in the Interest Rate of Selected East-Asian Countries, International Journal of Applied Business and Economic Research, Vol 7, Issue 2, pp. 97-105.\n\nAcademic Supervision\nDoctoral Degree (PhD), Ha Junsheng, Energy Industry with Wavelet application, 2013/2014 (Completed)\nMasters Degree, Lim Zhen Wen, The Great Gatsby Curve: Education and Income Inequality across Generations, 2014/2015 (Completed)\nMasters Degree, Liau Bee Yee, Text Mining for Low Cost Airlines in Malaysia, 2013/2014 (Completed)\nMasters Degree, Lim Thiam Sang, Dynamic Automobile Insurance Pricing in Malaysia: A Generalized Linear Model Approach, 2013/2014 (Completed)"
  },
  {
    "objectID": "R.html",
    "href": "R.html",
    "title": "R/Python",
    "section": "",
    "text": "with vs within\n\n\n\n\n\n\n\nR\n\n\nintermediate\n\n\nwith\n\n\n\n\nEvaluate expression in an environment\n\n\n\n\n\n\nJan 16, 2024\n\n\nJoan Tan\n\n\n\n\n\n\n  \n\n\n\n\nreduce in purrr\n\n\n\n\n\n\n\nR\n\n\nadvanced\n\n\nfunctional\n\n\n\n\nThe beauty of functional programming\n\n\n\n\n\n\nJan 15, 2024\n\n\nJoan Tan\n\n\n\n\n\n\n  \n\n\n\n\nWhat is functional programming (Part I)\n\n\n\n\n\n\n\nR\n\n\nadvanced\n\n\n\n\nA complimentary to OOP\n\n\n\n\n\n\nJan 14, 2024\n\n\nJoan Tan\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "Statistics.html",
    "href": "Statistics.html",
    "title": "Statistics",
    "section": "",
    "text": "No matching items"
  },
  {
    "objectID": "Python.html",
    "href": "Python.html",
    "title": "Python",
    "section": "",
    "text": "No matching items"
  },
  {
    "objectID": "Rposts/2024-01-14-functional-programming/index.html",
    "href": "Rposts/2024-01-14-functional-programming/index.html",
    "title": "What is functional programming (Part I)",
    "section": "",
    "text": "It actually took me a while to understand what functional programming is. So to give it a good start without getting too technical, I will start with a simple example.\nFunctional programming is like using a microwave. You put something in, press a button, and get something out. You don’t need to know how it works—the microwave takes care of that for you. You just need to know what buttons to press. This is the essence of functional programming. Whatever matters in this context is the ingredients of the food (data and input for the function) that you put together and place it inside the microwave, the function of the microwave that you choose (function(s)). The output is the dish that you get (output of the function). In an essence, you need input, function, and output."
  },
  {
    "objectID": "Rposts/2024-01-14-functional-programming/index.html#what-is-a-function",
    "href": "Rposts/2024-01-14-functional-programming/index.html#what-is-a-function",
    "title": "What is functional programming (Part I)",
    "section": "What is a function?",
    "text": "What is a function?\nA function is a block of code that performs a specific task. It takes in some input, performs some processing, and produces some output. A function is a self-contained block of code that encapsulates a specific task or related group of tasks. Functions usually “do” something, and they usually “return” something. The “something” that a function returns is called its return value. A function can have\n\nzero or more parameters. Parameters are inputs to the function;\nzero or more return values. Return values are outputs from the function.\n\nzero or more side effects. Side effects are outputs from the function that are not return values.\n\nR as a functional programming language, does not require you to write pure functions. A pure function is a function that has no side effects and always returns the same output for the same input. Imagine if you would like to generate random number from the function, then it is not a pure function. However, it is still a function.\n\n\n\n\n\n\nHadley Wickham\n\n\n\nA functional is a function that takes a function as an input and returns a vector as output.\n\n\nThe function that is passed in as an input is called a function argument. The function that is returned as an output is called a function output. There are lots of examples of functionals can be found in purrr package. For example, map() is a functional that takes a function as an input and returns a vector as output.\nFor simple illustration, let’s focus on the map() function.\n\nlibrary(purrr)\n\n\nsquare &lt;- function(x) x^2\nmap(1:3, square)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 9\n\n\nExplanation\n\nFirst, a square function is created.\n\nSecond, the map() function is called.\n\nThen, the first argument is a vector of 1 to 3. The second argument is the square function.\nThe map() function takes the square function as an input and returns a vector as output.\nThe map() function applies the square function to each element of the vector of 1 to 3.\nSo, it takes 1 and returns 1^2, then it takes 2 and returns 2^2, and so on.\nFinally, the map() function returns a vector of 1, 4, and 9 after it run the square function on each element of the vector of 1 to 3.\n\nSo let’s stop here and have a grasp on the concept of functional programming, before we explore more of this type of functions. To be continued…\nTo read more about functional programming, please visit Hadley Wickham’s Advanced R book, chapter 9 to 11."
  },
  {
    "objectID": "about.html#fa-person-chalkboard-titleexplain-my-profession",
    "href": "about.html#fa-person-chalkboard-titleexplain-my-profession",
    "title": "Who is Joan?",
    "section": "",
    "text": "I’m the educator/practitioner who is passionate about data science and teaching. I have been teaching data science courses for the past 12 years. I have taught over thousands of students. I have taught students from different backgrounds and different levels in different countries.\nMy background is in applied statistics – I was fortunate enough to obtain my undergraduate degree, master degree and my PhD degree all under various scholarships.\nI have been working in both the banking and education industry. Both are very fascinating and challenging. In reality, the practical side of statistics is very different from the theoretical side. I constantly need to learn new things and keep up with the latest technology. I am very fortunate to have the opportunity to work in both industries."
  },
  {
    "objectID": "about.html#fa-cake-candles-titlebaking-my-passion",
    "href": "about.html#fa-cake-candles-titlebaking-my-passion",
    "title": "Who is Joan?",
    "section": " My Passion",
    "text": "My Passion\nI adore baking! I enjoy trying out new recipes and serving my creations to loved ones. I also like to read productivity books since I think they are encouraging and inspirational. Other than this, I am a pretty boring person who dislike socializing. I would rather stay in, have a cup of hot chocolate, and do my own thing. Socialize consumes much of my energy and I feel wear out after that. It’s been a year since I first learned about minimalism, but I’m making a sincere effort to live one. Since I enjoy shopping, I’m still learning and getting used to this new way of life. Regretfully, minimalism design and shopping are two extremely contradicting ideas and I am still trying to find a balance between these two ideas."
  },
  {
    "objectID": "Resources.html",
    "href": "Resources.html",
    "title": "Resources",
    "section": "",
    "text": "Teaching"
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html",
    "title": "reduce in purrr",
    "section": "",
    "text": "One of the function that seems quite confusing at first but it works wonders when you unleashed its power is reduce from the purrr package.\nreduce() function is used to reduce a list to a single value by iteratively applying a binary function to each combination of the element of a vector. The examples below show three different level of examples to help understand how reduce() function works in each case here.\nThe general syntax of reduce() function is as follows:\nreduce(.x, .f, ..., .init = NULL)"
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html#what-is-a-function",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html#what-is-a-function",
    "title": "reduce in purrr",
    "section": "What is a function?",
    "text": "What is a function?\nA function is a block of code that performs a specific task. It takes in some input, performs some processing, and produces some output. A function is a self-contained block of code that encapsulates a specific task or related group of tasks. Functions usually “do” something, and they usually “return” something. The “something” that a function returns is called its return value. A function can have\n\nzero or more parameters. Parameters are inputs to the function;\nzero or more return values. Return values are outputs from the function.\n\nzero or more side effects. Side effects are outputs from the function that are not return values.\n\nR as a functional programming language, does not require you to write pure functions. A pure function is a function that has no side effects and always returns the same output for the same input. Imagine if you would like to generate random number from the function, then it is not a pure function. However, it is still a function.\n\n\n\n\n\n\nHadley Wickham\n\n\n\nA functional is a function that takes a function as an input and returns a vector as output.\n\n\nThe function that is passed in as an input is called a function argument. The function that is returned as an output is called a function output. There are lots of examples of functionals can be found in purrr package. For example, map() is a functional that takes a function as an input and returns a vector as output.\nFor simple illustration, let’s focus on the map() function.\n\nlibrary(purrr)\n\n\nsquare &lt;- function(x) x^2\nmap(1:3, square)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 9\n\n\nExplanation\n\nFirst, a square function is created.\n\nSecond, the map() function is called.\n\nThen, the first argument is a vector of 1 to 3. The second argument is the square function.\nThe map() function takes the square function as an input and returns a vector as output.\nThe map() function applies the square function to each element of the vector of 1 to 3.\nSo, it takes 1 and returns 1^2, then it takes 2 and returns 2^2, and so on.\nFinally, the map() function returns a vector of 1, 4, and 9 after it run the square function on each element of the vector of 1 to 3.\n\nSo let’s stop here and have a grasp on the concept of functional programming, before we explore more of this type of functions. To be continued…\nTo read more about functional programming, please visit Hadley Wickham’s Advanced R book, chapter 9 to 11."
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html#easy---example-1-summing-up-a-vector",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html#easy---example-1-summing-up-a-vector",
    "title": "reduce in purrr",
    "section": "Easy - Example 1: Summing up a vector",
    "text": "Easy - Example 1: Summing up a vector\n\nlibrary(purrr)\nx &lt;- c(1, 2, 3, 4, 5)\nreduce(x, `+`)\n\n[1] 15\n\n\nExplanation:\n\nx is a vector of numbers from 1 to 5\nreduce() function takes in two arguments: x and +\n+ is a function of two arguments, which is the sum of two numbers\nreduce() function will apply + function to each combination of the element of x vector\nreduce() function will return a single value, which is the sum of all the elements in x vector\nreduce() function is equivalent to sum(x)\nreduce() function is equivalent to sum(x, 0) if .init is specified\nin this case, the following iteration is performed.\n\nsum(1, 2) = 3 (sum of first 2 elements)\nsum(3, 3) = 6 (sum of first 2 elements plus third element)\nsum(6, 4) = 10 (sum of first 3 elements plus fourth element)\nsum(10, 5) = 15 (sum of first 4 elements plus fifth element) Therefore the reduce() function here simplify the procedure above and return only a single output of 15.\n\n\nYour turn \nTry to put the initial value of 10 to start with and see what happens. Can you explain?\n\nreduce(x, `+`, .init = 10)\n\n[1] 25"
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html#medium---example-2-summing-up-a-list-of-vectors",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html#medium---example-2-summing-up-a-list-of-vectors",
    "title": "reduce in purrr",
    "section": "Medium - Example 2: Summing up a list of vectors",
    "text": "Medium - Example 2: Summing up a list of vectors\n\nx &lt;- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9))\nx\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n\nreduce(x, `+`)\n\n[1] 12 15 18\n\n\nExplanation:\n\nx is a list of vectors.\n\nreduce() function takes in two arguments: x and +.\n\n+ is a function of two arguments, which is the sum of two numbers.\n\nreduce() function will apply + function to each combination of the element of x list.\n\nreduce() function is equivalent to sum(unlist(x)).\n\nreduce() function is equivalent to sum(unlist(x), 0) if .init is specified.\n\nin this case, the following iteration is performed.\n\nsum(1, 4, 7) = 12 (sum of first elements from each list).\n\nsum(2, 5, 8) = 15 (sum of first 2 elements).\n\nsum(3, 6, 9) = 10 (sum of first 3 elements).\nTherefore the reduce() function here simplify the procedure above and return only a single. output for each iterative summation procedure for first element, second element and third element respectively."
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html#example-1-summing-up-a-vector",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html#example-1-summing-up-a-vector",
    "title": "reduce in purrr",
    "section": "Example 1: Summing up a vector",
    "text": "Example 1: Summing up a vector\n\nlibrary(purrr)\nx &lt;- c(1, 2, 3, 4, 5)\nreduce(x, `+`)\n\n[1] 15\n\n\nExplanation:\n\nx is a vector of numbers from 1 to 5\nreduce() function takes in two arguments: x and +\n+ is a function of two arguments, which is the sum of two numbers\nreduce() function will apply + function to each combination of the element of x vector\nreduce() function will return a single value, which is the sum of all the elements in x vector\nreduce() function is equivalent to sum(x)\nreduce() function is equivalent to sum(x, 0) if .init is specified\nin this case, the following iteration is performed.\n\nsum(1, 2) = 3 (sum of first 2 elements)\nsum(3, 3) = 6 (sum of first 2 elements plus third element)\nsum(6, 4) = 10 (sum of first 3 elements plus fourth element)\nsum(10, 5) = 15 (sum of first 4 elements plus fifth element) Therefore the reduce() function here simplify the procedure above and return only a single output of 15.\n\n\nYour turn \nTry to put the initial value of 10 to start with and see what happens. Can you explain?\n\nreduce(x, `+`, .init = 10)\n\n[1] 25"
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html#example-2-summing-up-a-list-of-vectors",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html#example-2-summing-up-a-list-of-vectors",
    "title": "reduce in purrr",
    "section": "Example 2: Summing up a list of vectors",
    "text": "Example 2: Summing up a list of vectors\n\nx &lt;- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9))\nx\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n\nreduce(x, `+`)\n\n[1] 12 15 18\n\n\nExplanation:\n\nx is a list of vectors.\n\nreduce() function takes in two arguments: x and +.\n\n+ is a function of two arguments, which is the sum of two numbers.\n\nreduce() function will apply + function to each combination of the element of x list.\n\nreduce() function is equivalent to sum(unlist(x)).\n\nreduce() function is equivalent to sum(unlist(x), 0) if .init is specified.\n\nin this case, the following iteration is performed.\n\nsum(1, 4, 7) = 12 (sum of first elements from each list).\n\nsum(2, 5, 8) = 15 (sum of first 2 elements).\n\nsum(3, 6, 9) = 10 (sum of first 3 elements).\nTherefore the reduce() function here simplify the procedure above and return only a single. output for each iterative summation procedure for first element, second element and third element respectively."
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html#example-3-calculate-rolling-sum-for-3-lags-value",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html#example-3-calculate-rolling-sum-for-3-lags-value",
    "title": "reduce in purrr",
    "section": "Example 3: Calculate rolling sum for 3 lags value",
    "text": "Example 3: Calculate rolling sum for 3 lags value\n\nlibrary(tidyverse)\n\n\nset.seed(123)\nx &lt;- tibble(day = 1:10, \n               value = rnorm(n = 10))\n\nx %&gt;% \n  mutate(testing = reduce(map(0:2, ~lag(value, .x)), `+`)) \n\n# A tibble: 10 × 3\n     day   value testing\n   &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1     1 -0.560   NA    \n 2     2 -0.230   NA    \n 3     3  1.56     0.768\n 4     4  0.0705   1.40 \n 5     5  0.129    1.76 \n 6     6  1.72     1.91 \n 7     7  0.461    2.31 \n 8     8 -1.27     0.911\n 9     9 -0.687   -1.49 \n10    10 -0.446   -2.40 \n\n\nExplanation:\n\nx is a tibble with 2 columns: day and value.\nday is a sequence of numbers from 1 to 10.\nvalue is a sequence of random numbers generated from normal distribution.\nmap() function is used to apply lag() function to each element of the vector 0:2.\nlag() function is used to shift the value of value column by 0, 1 and 2 lags respectively.\nreduce() function is used to apply + function to each combination of the element of map() function.\nreduce() function is equivalent to lag(value, 0) + lag(value, 1) + lag(value, 2).\nin this case, the following iteration is performed.\n\nday 1: lag(value, 0) + lag(value, 1) + lag(value, 2) = -0.560 + NA + NA = NA\nday 2: lag(value, 0) + lag(value, 1) + lag(value, 2) = -0.230 + NA + NA = NA\nday 3: lag(value, 0) + lag(value, 1) + lag(value, 2) = 1.558 + -0.230 + -0.560 = 0.768\nday 4: lag(value, 0) + lag(value, 1) + lag(value, 2) = 0.070 + 1.558 + -0.230 = 1.399\nday 5: lag(value, 0) + lag(value, 1) + lag(value, 2) = 0.129 + 0.070 + 1.558 = 1.757 and so on. This is equivalent to the rollsum() function from the zoo package. It basically calculate the rolling sum for the last 3 lags value."
  },
  {
    "objectID": "Rposts/2024-01-16-with-within/index.html",
    "href": "Rposts/2024-01-16-with-within/index.html",
    "title": "with vs within",
    "section": "",
    "text": "with evaluates an expression in an environment constructed from data, possibly modifying the data in the process. within is similar to with, except that it modifies the data frame directly and only examines the environemnt after the evaluation of the expression.\nCase study 1: to create a new variable new_var in df that is the sum of var1 and var2\n\ndf &lt;- data.frame(var1 = 1:10, var2 = 11:20)\ndf\n\n   var1 var2\n1     1   11\n2     2   12\n3     3   13\n4     4   14\n5     5   15\n6     6   16\n7     7   17\n8     8   18\n9     9   19\n10   10   20\n\n# Method 1: with\ndf$new_var &lt;- with(df, var1 + var2) \n# is equivalent to\ndf$new_var &lt;- df$var1 + df$var2\n\ndf\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30\n\n# Method 2: within\nwithin(df, new_var &lt;- var1 + var2)\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30\n\n# Method 3: mutate\nlibrary(dplyr)\ndf %&gt;% mutate(new_var = var1 + var2)\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30\n\n\nCase study 2: to create a new variable new_var in df that is the sum of var1 and var2; new_var2 is the product of var1 and var3.\n\ndf &lt;- data.frame(var1 = 1:10, var2 = 11:20, var3 = 21:30)\nwithin(df, {\n  new_var &lt;- var1 + var2\n  new_var2 &lt;- var1 * var3\n})\n\n   var1 var2 var3 new_var2 new_var\n1     1   11   21       21      12\n2     2   12   22       44      14\n3     3   13   23       69      16\n4     4   14   24       96      18\n5     5   15   25      125      20\n6     6   16   26      156      22\n7     7   17   27      189      24\n8     8   18   28      224      26\n9     9   19   29      261      28\n10   10   20   30      300      30\n\ndf\n\n   var1 var2 var3\n1     1   11   21\n2     2   12   22\n3     3   13   23\n4     4   14   24\n5     5   15   25\n6     6   16   26\n7     7   17   27\n8     8   18   28\n9     9   19   29\n10   10   20   30\n\n\nIn the code chunk above, two new columns are being created and please note that no column has been added to the original data. You have to assign the output from the within environment to a new object.\n\n\n\nCitationBibTeX citation:@online{tan2024,\n  author = {Tan, Joan},\n  title = {`With` Vs `Within`},\n  date = {2024-01-16},\n  url = {https://joantan.org/R/2024-01-16-with-within/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nTan, Joan. 2024. “`With` Vs `Within` .” January 16, 2024.\nhttps://joantan.org/R/2024-01-16-with-within/."
  },
  {
    "objectID": "Rposts/2024-01-16-with-within/index.html#example-1-summing-up-a-vector",
    "href": "Rposts/2024-01-16-with-within/index.html#example-1-summing-up-a-vector",
    "title": "reduce in purrr",
    "section": "Example 1: Summing up a vector",
    "text": "Example 1: Summing up a vector\n\nlibrary(purrr)\nx &lt;- c(1, 2, 3, 4, 5)\nreduce(x, `+`)\n\n[1] 15\n\n\nExplanation:\n\nx is a vector of numbers from 1 to 5\nreduce() function takes in two arguments: x and +\n+ is a function of two arguments, which is the sum of two numbers\nreduce() function will apply + function to each combination of the element of x vector\nreduce() function will return a single value, which is the sum of all the elements in x vector\nreduce() function is equivalent to sum(x)\nreduce() function is equivalent to sum(x, 0) if .init is specified\nin this case, the following iteration is performed.\n\nsum(1, 2) = 3 (sum of first 2 elements)\nsum(3, 3) = 6 (sum of first 2 elements plus third element)\nsum(6, 4) = 10 (sum of first 3 elements plus fourth element)\nsum(10, 5) = 15 (sum of first 4 elements plus fifth element) Therefore the reduce() function here simplify the procedure above and return only a single output of 15.\n\n\nYour turn \nTry to put the initial value of 10 to start with and see what happens. Can you explain?\n\nreduce(x, `+`, .init = 10)\n\n[1] 25"
  },
  {
    "objectID": "Rposts/2024-01-16-with-within/index.html#example-2-summing-up-a-list-of-vectors",
    "href": "Rposts/2024-01-16-with-within/index.html#example-2-summing-up-a-list-of-vectors",
    "title": "reduce in purrr",
    "section": "Example 2: Summing up a list of vectors",
    "text": "Example 2: Summing up a list of vectors\n\nx &lt;- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9))\nx\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n\nreduce(x, `+`)\n\n[1] 12 15 18\n\n\nExplanation:\n\nx is a list of vectors.\n\nreduce() function takes in two arguments: x and +.\n\n+ is a function of two arguments, which is the sum of two numbers.\n\nreduce() function will apply + function to each combination of the element of x list.\n\nreduce() function is equivalent to sum(unlist(x)).\n\nreduce() function is equivalent to sum(unlist(x), 0) if .init is specified.\n\nin this case, the following iteration is performed.\n\nsum(1, 4, 7) = 12 (sum of first elements from each list).\n\nsum(2, 5, 8) = 15 (sum of first 2 elements).\n\nsum(3, 6, 9) = 10 (sum of first 3 elements).\nTherefore the reduce() function here simplify the procedure above and return only a single. output for each iterative summation procedure for first element, second element and third element respectively."
  },
  {
    "objectID": "Rposts/2024-01-16-with-within/index.html#example-3-calculate-rolling-sum-for-3-lags-value",
    "href": "Rposts/2024-01-16-with-within/index.html#example-3-calculate-rolling-sum-for-3-lags-value",
    "title": "reduce in purrr",
    "section": "Example 3: Calculate rolling sum for 3 lags value",
    "text": "Example 3: Calculate rolling sum for 3 lags value\n\nlibrary(tidyverse)\n\n\nset.seed(123)\nx &lt;- tibble(day = 1:10, \n               value = rnorm(n = 10))\n\nx %&gt;% \n  mutate(testing = reduce(map(0:2, ~lag(value, .x)), `+`)) \n\n# A tibble: 10 × 3\n     day   value testing\n   &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1     1 -0.560   NA    \n 2     2 -0.230   NA    \n 3     3  1.56     0.768\n 4     4  0.0705   1.40 \n 5     5  0.129    1.76 \n 6     6  1.72     1.91 \n 7     7  0.461    2.31 \n 8     8 -1.27     0.911\n 9     9 -0.687   -1.49 \n10    10 -0.446   -2.40 \n\n\nExplanation:\n\nx is a tibble with 2 columns: day and value.\nday is a sequence of numbers from 1 to 10.\nvalue is a sequence of random numbers generated from normal distribution.\nmap() function is used to apply lag() function to each element of the vector 0:2.\nlag() function is used to shift the value of value column by 0, 1 and 2 lags respectively.\nreduce() function is used to apply + function to each combination of the element of map() function.\nreduce() function is equivalent to lag(value, 0) + lag(value, 1) + lag(value, 2).\nin this case, the following iteration is performed.\n\nday 1: lag(value, 0) + lag(value, 1) + lag(value, 2) = -0.560 + NA + NA = NA\nday 2: lag(value, 0) + lag(value, 1) + lag(value, 2) = -0.230 + NA + NA = NA\nday 3: lag(value, 0) + lag(value, 1) + lag(value, 2) = 1.558 + -0.230 + -0.560 = 0.768\nday 4: lag(value, 0) + lag(value, 1) + lag(value, 2) = 0.070 + 1.558 + -0.230 = 1.399\nday 5: lag(value, 0) + lag(value, 1) + lag(value, 2) = 0.129 + 0.070 + 1.558 = 1.757 and so on. This is equivalent to the rollsum() function from the zoo package. It basically calculate the rolling sum for the last 3 lags value."
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html#case-study-1",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html#case-study-1",
    "title": "wtih vs within evaluate expression in an environment",
    "section": "Case study 1",
    "text": "Case study 1\n\nObj: to create a new variable new_var in df that is the sum of var1 and var2\n\ndf &lt;- data.frame(var1 = 1:10, var2 = 11:20)\ndf\n\n   var1 var2\n1     1   11\n2     2   12\n3     3   13\n4     4   14\n5     5   15\n6     6   16\n7     7   17\n8     8   18\n9     9   19\n10   10   20\n\n# Method 1: with\ndf$new_var &lt;- with(df, var1 + var2) \n# is equivalent to\ndf$new_var &lt;- df$var1 + df$var2\n\ndf\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30\n\n# Method 2: within\nwithin(df, new_var &lt;- var1 + var2)\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30\n\ndf\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30\n\n# Method 3: mutate\nlibrary(dplyr)\ndf %&gt;% mutate(new_var = var1 + var2)\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30"
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html#case-study-2",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html#case-study-2",
    "title": "wtih vs within evaluate expression in an environment",
    "section": "Case study 2",
    "text": "Case study 2\n\nObj: to create a new variable new_var in df that is the sum of var1 and var2; new_var2 is the product of var1 and var3.\n\ndf &lt;- data.frame(var1 = 1:10, var2 = 11:20, var3 = 21:30)\nwith(df, {\n  new_var &lt;- var1 + var2\n  new_var2 &lt;- var1 * var3\n})"
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html#case-study-1-to-create-a-new-variable-new_var-in-df-that-is-the-sum-of-var1-and-var2",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html#case-study-1-to-create-a-new-variable-new_var-in-df-that-is-the-sum-of-var1-and-var2",
    "title": "wtih vs within evaluate expression in an environment",
    "section": "Case study 1: to create a new variable new_var in df that is the sum of var1 and var2",
    "text": "Case study 1: to create a new variable new_var in df that is the sum of var1 and var2\n\ndf &lt;- data.frame(var1 = 1:10, var2 = 11:20)\ndf\n\n   var1 var2\n1     1   11\n2     2   12\n3     3   13\n4     4   14\n5     5   15\n6     6   16\n7     7   17\n8     8   18\n9     9   19\n10   10   20\n\n# Method 1: with\ndf$new_var &lt;- with(df, var1 + var2) \n# is equivalent to\ndf$new_var &lt;- df$var1 + df$var2\n\ndf\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30\n\n# Method 2: within\nwithin(df, new_var &lt;- var1 + var2)\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30\n\ndf\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30\n\n# Method 3: mutate\nlibrary(dplyr)\ndf %&gt;% mutate(new_var = var1 + var2)\n\n   var1 var2 new_var\n1     1   11      12\n2     2   12      14\n3     3   13      16\n4     4   14      18\n5     5   15      20\n6     6   16      22\n7     7   17      24\n8     8   18      26\n9     9   19      28\n10   10   20      30"
  },
  {
    "objectID": "Rposts/2024-01-15-purrr-reduce/index.html#case-study-2-to-create-a-new-variable-new_var-in-df-that-is-the-sum-of-var1-and-var2-new_var2-is-the-product-of-var1-and-var3.",
    "href": "Rposts/2024-01-15-purrr-reduce/index.html#case-study-2-to-create-a-new-variable-new_var-in-df-that-is-the-sum-of-var1-and-var2-new_var2-is-the-product-of-var1-and-var3.",
    "title": "wtih vs within evaluate expression in an environment",
    "section": "Case study 2: to create a new variable new_var in df that is the sum of var1 and var2; new_var2 is the product of var1 and var3.",
    "text": "Case study 2: to create a new variable new_var in df that is the sum of var1 and var2; new_var2 is the product of var1 and var3.\n\ndf &lt;- data.frame(var1 = 1:10, var2 = 11:20, var3 = 21:30)\nwith(df, {\n  new_var &lt;- var1 + var2\n  new_var2 &lt;- var1 * var3\n})"
  }
]